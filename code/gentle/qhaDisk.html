<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.23.0/cytoscape.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dagre/0.8.5/dagre.min.js "></script>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.5.1/snap.svg-min.js"></script>
    <script src="logger.min.js"></script>
    <script src="LNakayama.min.js"></script>
    <script src="DiskModel.min.js"></script>
    <script src="cyto4poset.js"></script>
    <style>
        .bkg {
            background-color: #039403;
        }


        :root {
            --canvas-height: max(500px, 80vh);
        }

        #container {
            min-height: 96vh;
            display: grid;
            /* flex-flow: column; */
            grid-template-areas: "control"
                "allviewers";
            grid-template-rows: 1fr auto;
        }

        #control {
            grid-area: control;
            margin: 1rem;
            display: flex;
            flex-flow: row;
            /* flex-wrap: nowrap; */
            /* justify-content: normal; */
            align-items: flex-start;
        }

        #control>div {
            border: 1px dashed #AAA;
            padding: 5px;
            margin: 2px 5px;
            width: max-content;
        }

        #allviewers {
            grid-area: allviewers;
            display: grid;
            grid-template-areas: "disk poset qhs";
            grid-template-columns: 460px 150px auto;
            gap: .5em;
            align-items: center;
            justify-items: stretch;
            height: var(--canvas-height);
            max-height: 100vh;
            /* flex-grow: 1; */
        }

        #svgDiv {
            grid-area: disk;
            box-sizing: border-box;
            width: 100%;
            height: var(--canvas-height);
            border: 1px solid black
        }

        #svg {
            width: 100%;
            box-sizing: border-box;
            height: var(--canvas-height);
        }

        .cytoDiv {
            box-sizing: border-box;
            width: 100%;
            height: var(--canvas-height);
            border: 1px #000000 solid;
            display: grid;
            justify-items: center;
            align-items: center;
        }

        #qhsDiv {
            grid-area: qhs;
        }

        #posetDiv {
            grid-area: poset;
        }

        .viewer {
            width: 100%;
            box-sizing: border-box;
            height: var(--canvas-height);
        }

        .cy_canvas {
            box-sizing: border-box;
            width: 100%;
            height: var(--canvas-height);
            display: block;
        }
    </style>
    <title>LNakayama and its disk model</title>
</head>

<body>
    <div id="container">
        <div id="control" style="margin:5px;">
            <div id="addModule">
                Kupisch series: <input type="text" name="kupish" id="kupisch" , value="[3,2,4,3,2,2,1]">
                <br><button onclick="generate()">Generate</button>
                <br><br>
                Show module(s) on disk: <br>
                <!-- [ <input type="number" name="topM0" id="topM0"> , <input type="number" name="socM0" id="socM0"> ] -->
                <!-- <textarea name="modulesInput" id="modulesInput" cols="70" rows="3"
                    style="display:inline-block; vertical-align: top;">[[1,3],[2,2],[3,5],[4,4]]</textarea> -->
                <input type="text" name="modulesInput" id="modulesInput" size="35"
                    placeholder="[[1,3],[2,2],[3,5],[4,4]]">
                <div style="display:inline-block; vertical-align: middle; margin-left:.2em;">
                    <button onclick="addModulesFromInput()">Draw</button>
                </div>
            </div>
            <div>
                Translate to TikZ <br>
                <label><input type="checkbox" name="" id="withdualarc" checked>with dual arc system</label> <br>
                <label><input type="checkbox" name="" id="withdissection">with dissection</label> <br>
                <label><input type="checkbox" name="" id="withmodules" checked>with modules shown</label> <br>
                <button onclick="printTikz()" style="margin-top:1ch;">Translate</button>
            </div>
            <div style="display:flex; flex-direction:column;">
                <div style="display:block;">
                    <button onclick="genQHS()">Gen all qh structure</button><br>
                    <button onclick="cyto.fit()">Fit Hasse quiver to canvas</button>
                    <!-- <button onclick="genTilt()" disabled>Gen all gen. tilting (TODO)</button> -->
                </div>
                <div style="display:block;margin-top:2ch;">
                    Reduction at: <br>
                    <input type="text" id="selectModule" cols="20" placeholder="[[1,3],[2,2]]"><br>
                    <button id="btnSelectModule" onclick="filtTilt()" disabled>Filter</button>
                    <button onclick="clearHighlight()">Clear Highlight</button>
                </div>
                <!-- <button onclick="removeModule()">Remove</buttononclick> -->
            </div>
            <div>
                <textarea name="log" id="log" cols="70" rows="6" style="margin:5px;overflow:scroll">~Log~</textarea>
            </div>

        </div>
        <div id="allviewers">
            <div id="svgDiv">
                <svg id="svg">
                    <defs>
                        <!-- <marker id="arrowhead" name="arrowhead" markerWidth="10" markerHeight="8" refX="9.5" refY="5.1"
                    orient="auto" markerUnits="userSpaceOnUse">
                    <polyline points="1 1, 9 5, 1 7" />
                </marker> -->
                        <marker markerWidth="5" markerHeight="5" refX="2.5" refY="2.5" viewBox="0 0 5 5" orient="auto"
                            id="arrowhead">
                            <polygon points="0,5 1.6666666666666667,2.5 0,0 5,2.5"></polygon>
                        </marker>
                    </defs>
                    <!-- <line id="myline" x1="10" y1="10" x2="90" y2="90" stroke="black" marker-end="url(#arrowhead)" /> -->
                    <!-- <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" /> -->
                </svg>
            </div>

            <div id="posetDiv" class="cytoDiv">
                <div class="viewer">
                    <span>min. ad. order</span>
                    <div id="cyPoset" class="cy_canvas"></div>
                </div>
            </div>

            <div id="qhsDiv" class="cytoDiv">
                <div class="viewer">
                    <span id="sysOutput">qhs(A)</span>
                    <div id="cyQHS" class="cy_canvas"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        var s = Snap("#svg");
        var cx = 230, cy = 270; //center of graph
        var g = 0.35; // gravity towards center of graph
        var r = 180, vxR = 6; // r=radius of big disk, vxR=radius of mk pts
        var greenPos = [], redPos = [], labelPos = []; // store positions of green/red mk pts
        var modules = [], arcs = [];
        var qhs;
        var A, disk, QR;
        var cyto, posetCyto;
        var arrowhead = s.select("#arrowhead");
        var logArea = document.getElementById("log");

        function polarToCartesian(radius, degree, cx, cy) {
            // Convert degree to radians
            var radians = (degree - 90) * Math.PI / 180;

            // Calculate x and y coordinates
            var x = radius * Math.cos(radians);
            var y = radius * Math.sin(radians);

            // Return x,y tuple
            return [cx + x, cy + y];
        }

        /**
         * @param  {string} str
         * @return {number} -1 if not a string or not valid array; otherwise the dimension of array
         */
        function detectStringifiedArrayDim(str) {
            if (typeof str != "string") {
                console.log("detectStringifiedArrayDim: require input is a string.");
                return -1;
            }
            let count = 0;
            for (let i = 0; i < str.length; i++) {
                if (str[i] === "[") {
                    count++;
                } else {
                    break;
                }
            }
            // dim = 0 if no brackets
            return count == 0 ? -1 : count;
        }
        function SplitArrayOfArrayString(str) {
            return str.split("],[").join("]||[").split("||");
        }

        function fracToPoint(start, end, ratio) {
            return [(1 - ratio) * start[0] + ratio * end[0], (1 - ratio) * start[1] + ratio * end[1]];
        }

        function computeMkptPosition(m, withLabel = false) {
            var angleIncrement = 360 / m; // angle increment between vertices
            var green = [], red = [], labels = [];
            for (let i = 0; i < m; i++) {
                var angle = angleIncrement * i;
                //add marked points positions
                //postive angle = clockwise direction from 12 o'clock
                [green, red].forEach((vxs, j) =>
                    vxs.push(polarToCartesian(r, angle + j * angleIncrement / 2, cx, cy)));

                // add labels positions
                if (withLabel) {
                    labels.push(polarToCartesian(r + 2.5 * vxR + 3, angle, cx, cy));
                }
            }
            return [green, red, labels];
        }

        function drawDisk(recompute = false) {
            var base = s.circle(cx, cy, r);
            base.attr({
                fill: "none",
                stroke: "#000",
                strokeWidth: 3
            });
            let [green, red, labels] = recompute ? computeMkptPosition(disk.m, true) : [greenPos, redPos, labelPos];

            var fills = ["#FFF", "#F00"];
            var strokes = ["#0F0", "#F00"];
            [green, red].forEach((posArr, j) => {
                posArr.forEach(([x, y]) => {
                    let v = s.circle(x, y, vxR);
                    v.attr({
                        fill: fills[j],
                        stroke: strokes[j],
                        strokeWidth: 1.5
                    });
                });
            })
            labels.forEach(([x, y], i) => {
                var txt = s.text(x, y, `${i + 1}`);
                txt.attr({
                    "text-anchor": "middle",
                    "dominant-baseline": "central",
                    "font-size": "10pt"
                });
            });
        }

        function drawCurveOnDisk(start, end) {
            let ctrl0 = fracToPoint(start, [cx, cy], g);
            let ctrl1 = fracToPoint(end, [cx, cy], g);
            return s.path(`M${start} C${ctrl0} ${ctrl1} ${end}`);
        }

        // use withLabel = {text: t, pos: r, abspos: [x,y], opt: {...}} to 
        // change label text to t, and display position (ratio r on the arc), or
        // display at absolute position [x,y]
        // opt value determines additional attributes to the asociated text object
        function drawArc(arc, type, withLabel = null, opt = { strokeWidth: 2, fill: "none" }) {
            let start, end;
            if (type == "green") {
                start = greenPos[arc[0] - 1];
                end = greenPos[arc[1] - 1];
                opt.stroke = opt.stroke ? opt.stroke : "#0B0";
            } else if (type == "red") {
                start = redPos[arc[0] - 1];
                end = redPos[arc[1] - 1];
                opt.stroke = opt.stroke ? opt.stroke : "#F00";
            }

            let a = drawCurveOnDisk(start, end);
            a.attr(opt);
            if (withLabel) {
                //let [x, y] = fracToPoint(fracToPoint(start, end, (withLabel.pos ? withLabel.pos : 0.5)), [cx, cy], g - 0.1);
                let len = a.getTotalLength();
                let { x, y } = a.getPointAtLength(len * (withLabel.pos ? withLabel.pos : 0.5));
                let txt = s.text(x, y, withLabel.text);
                txt.attr({
                    "font-family": "monospace",
                    "font-size": withLabel['font-size'] ? withLabel['font-size'] : "9pt",
                    "text-anchor": "middle",
                    "dominant-baseline": "central",
                })
                if (Array.isArray(withLabel.text) && withLabel.text.length > 1) {
                    let dy = withLabel.text.length * 10 / 2;
                    txt.selectAll("tspan").forEach(function (tspan, i) {
                        tspan.attr({ x: x, y: y - dy + 10 * i });
                    });
                }
                if (withLabel.bounded) {
                    let bbox = txt.getBBox();
                    let rect = s.rect(bbox.x - 2, bbox.y - 2, bbox.width + 4, bbox.height + 4);
                    rect.attr({
                        fill: "#ddd",
                        "fill-opacity": 0.8,
                        stroke: "#000",
                        strokeWidth: 1
                    });
                    rect.insertBefore(txt);
                }
                //　TODO　withLabel.opt ? txt.attr(withLabel.opt) : null;
            }
        }

        function drawDualArcSys(clear = true, onlyarcs = true) {
            clear ? s.selectAll('svg > *:not(defs)').remove() : null;
            for (let a of disk.arcsys) { drawArc(a, "red"); }
            onlyarcs ? null : drawDisk(false);
        }

        function drawQuiverAndRelations() {
            let ox = 25, oy = 40; //relative origin
            let sep = 60; // how far apart consecutive vertices are
            let xpos = Array(A.rank).fill(0).map((x, i) => ox + i * sep);
            QR = s.g();
            //quiver
            for (let i = 0; i < A.rank; i++) {
                let txt = s.text(xpos[i], oy, `${i + 1}`);
                txt.attr({
                    "text-anchor": "middle",
                    "dominant-baseline": "central",
                    "font-size": "12pt"
                });
                QR.add(txt);
                if (i > 0) {
                    let arrow = s.line(xpos[i - 1] + 10, oy, xpos[i] - 15, oy);
                    arrow.attr({
                        stroke: "#000",
                        strokeWidth: 2,
                        markerEnd: arrowhead
                    });
                    QR.add(arrow);
                }
            }
            //relations
            let rels = A.relations;
            for (let r of rels) {
                let l = r[1] - r[0]
                let x0 = ox + r[0] * sep + sep / 2;
                let x1 = ox + (r[1] - 1) * sep + sep / 2;
                let dash = s.path(`M${x0 + 2},${oy - 3} C${x0 + 20},${oy - 23} ${x1 - 20},${oy - 23} ${x1 - 2},${oy - 3}`);
                dash.attr({
                    stroke: "#000",
                    strokeDasharray: "10,5",
                    strokeWidth: 1,
                    fill: "none"
                })
                QR.add(dash);
            }
            //scale if needed
            (A.rank - 1) * sep > 420 ? QR.attr({
                transform: `scale(${420 / ((A.rank - 1) * sep)})`
            }) : null;
        }

        function generate() {
            document.getElementById("btnSelectModule").disabled = true;
            qhs = [];
            s.selectAll('svg > *:not(defs)').remove(); //s.clear() will remove everything under <defs> too
            let kup = JSON.parse(document.getElementById("kupisch").value);
            disk = new DiskModel(kup);
            A = disk.algebra;
            if (A.isGentle) {
                [greenPos, redPos, labelPos] = computeMkptPosition(disk.valencies.length, true);
                for (let [i, a] of Object.entries(disk.dissection)) { drawArc(a, "green", { text: `${parseInt(i) + 1}`, "font-size": "12pt" }); }
                drawDualArcSys(false, false);
                updateLog("-------New Disk------");
            } else {
                updateLog("Algebra is not gentle; disk will NOT be drawn.");
            }

            drawQuiverAndRelations();
        }

        function LoewyDiagram(top, soc) {
            return Array.from(Array(parseInt(soc) + 1 - parseInt(top)).keys(), i => `${parseInt(top) + i}`);
        }

        function drawLoewyDiagram(x, y, Loewy) {
            let txt = s.text(x, y, Loewy);
            txt.attr({
                "font-family": "monospace",
                "font-size": "9pt",
                "text-anchor": "middle",
                "dominant-baseline": "central",
            })
            if (Loewy.length > 1) {
                let dy = Loewy.length * 10 / 2;
                txt.selectAll("tspan").forEach(function (tspan, i) {
                    tspan.attr({ x: x, y: y - dy + 10 * i });
                });
            }
            let bbox = txt.getBBox();
            let rect = s.rect(bbox.x - 2, bbox.y - 2, bbox.width + 4, bbox.height + 4);
            rect.attr({
                fill: "#ddd",
                "fill-opacity": 0.8,
                stroke: "#000",
                strokeWidth: 1
            });
            rect.insertBefore(txt);
        }

        function addModulesFromInput() {
            let strMs = document.getElementById("modulesInput").value;
            let dim = detectStringifiedArrayDim(strMs);
            let Ms = dim == 2 ? JSON.parse(strMs) : [JSON.parse(strMs)];
            addModules(Ms);
        }

        function addModules(Ms) {
            modules = [], arcs = [];
            for (let M of Ms) {
                A.isModule(M) ? modules.push({ topsoc: M, Loewy: LoewyDiagram(...M) }) : null;
            }

            // draw
            drawQuiverAndRelations();
            if (A.isGentle) {
                drawDualArcSys(true, true);
                for (let [i, M] of Object.entries(modules)) {
                    let a = disk.moduleToLaminate(M.topsoc);
                    arcs.push(a);
                    drawArc(a, "green", { text: M.Loewy, bounded: true }, { stroke: "#00F", strokeWidth: 2, fill: "none" });
                }
                drawDisk(false);
            } else {
                s.selectAll('svg > *:not(defs)').remove();
                drawQuiverAndRelations();
                let ox = 30, oy = 100;
                for (let [i, M] of Object.entries(modules)) {
                    drawLoewyDiagram(ox + i * 25, oy, M.Loewy);
                }
            }

            // display log
            updateLog();
        }

        function filtTilt() {
            let strMs = document.getElementById("selectModule").value;
            let dim = detectStringifiedArrayDim(strMs);
            let Ms = dim == 2 ? JSON.parse(strMs) : [JSON.parse(strMs)];
            // console.log(Ms);
            let matchingID = [];
            for (let n of cyto.elements("node")) {
                n.unselect();
                n.removeClass("inList");
            }
            // console.log(qhs.qhs);
            for (let [i, T] of Object.entries(qhs.qhs.map((q) => q.charTilt))) {
                // console.log(`i=${i}, T=[${T}]`);
                if (A.isDirectSummand(Ms, T)) {
                    let node = cyto.getElementById(`${parseInt(i) + 1}`);
                    node.addClass("inList");
                    node.select();
                    matchingID.push(i);
                }
            }
            updateLog(`Found ${matchingID.length} char.tilting containing direct sumnand ${JSON.stringify(Ms)}.`);
        }

        function updateLog(str = "") {
            logArea.innerHTML += `\n${str}\n` + disk.log.allFromLastGet.join("\n");
            // console.log(`lastGet: ${disk.log.lastGet}.  logLenL: ${disk.log.log.length}`);
            logArea.scrollTop = logArea.scrollHeight;
        }

        function genQHS() {
            qhs = A.findAllMAOs();
            updateLog();

            var poset = coverArrayToCyto(qhs.coverRel);
            cyto = initSVG(document.getElementById("cyQHS"), poset);
            cyto.on("tap", "node", (e) => showTilting(e.target));
            document.getElementById("btnSelectModule").disabled = false;
        }

        function showTilting(node) {
            let struc = qhs.qhs[parseInt(node.id()) - 1];
            posetCyto = initSVG(document.getElementById("cyPoset"), coverArrayToCyto(struc.coverRel));
            // console.log(`tilting module (id=${node.id()}) = `, A.charTilting(struc.std, struc.costd));
            addModules(A.charTilting(struc.std, struc.costd));
        }

        function clearHighlight() {
            for (let n of cyto.elements("node")) {
                n.removeClass("inList");
            }
        }

        /***********************
         * 
         * Tikz Convert
         * 
         */

        function printTikz() {
            let withdualarc = document.getElementById("withdualarc").checked;
            let withdissection = document.getElementById("withdissection").checked;
            let withmodules = document.getElementById("withmodules").checked;
            let res = `\\begin{tikzpicture}\n`;
            res += `\\draw  (0,0) circle (2);\n`;
            let d = 360 / disk.m;
            let greens = Array.from({ length: disk.m }, (_, i) => 90 - i * d);
            res += greens.map((_, i) => `\\node[inner sep=0pt] (g${i + 1}) at (${greens[i]}:2) {};\\node[inner sep=0pt] (r${i + 1}) at (${greens[i] + d / 2}:2) {};\n`).join("");

            //curves
            res += withdualarc ? disk.arcsys.map((a) => `\\draw[red] (r${a[0]}) .. controls (${greens[a[0] - 1] + d / 2}:1.2) and (${greens[a[1] - 1] + d / 2}:1.2) .. (r${a[1]});\n`).join("") : "";
            res += withdissection ? disk.dissection.map((a) => `\\draw[green!70!black] (g${a[0]}) .. controls (${greens[a[0] - 1]}:1.2) and (${greens[a[1] - 1]}:1.2) .. (g${a[1]});\n`).join("") : "";
            res += withmodules ? arcs.map((a) => `\\draw[blue,thick] (g${a[0]}) .. controls (${greens[a[0] - 1]}:1.2) and (${greens[a[1] - 1]}:1.2) .. (g${a[1]});\n`).join("") : "";

            //marked points
            res += greens.map((a, i) => `\\filldraw[green!70!black,fill=white] (g${i + 1}) circle (0.05);\n`).join("");
            res += greens.map((a, i) => `\\fill[red] (r${i + 1}) circle (0.05);\n`).join("");

            res += `\\end{tikzpicture}`;

            copyToClipboard(res).then(() => { updateLog("✔ TikZ output copied to clipboard!"); })
                .catch((error) => {
                    updateLog("⚠ ERROR: TikZ output cannot be copied to clipboard!  Showing output here:");
                    updateLog("-----------------------------");
                    updateLog(res);
                    updateLog("-----------------------------");
                    console.error("⚠ Failed to copy text to clipboard", error);
                });
            return res;
        }

        async function copyToClipboard(txt) {
            /**
             * c.f. https://stackoverflow.com/questions/71873824/copy-text-to-clipboard-cannot-read-properties-of-undefined-reading-writetext
             * Copies the text passed as param to the system clipboard
             * Check if using HTTPS and navigator.clipboard is available
             * Then uses standard clipboard API, otherwise uses fallback
            */
            if (window.isSecureContext && navigator.clipboard) {
                navigator.clipboard.writeText(txt);
            } else {
                const textArea = document.createElement("textarea");
                textArea.value = txt;
                document.body.appendChild(textArea);
                textArea.focus(); textArea.select();
                try { document.execCommand('copy') } catch (err) { console.error('Unable to copy text to clipboard with execCommand', err) }
                document.body.removeChild(textArea);
            }
        }
    </script>
</body>

</html>
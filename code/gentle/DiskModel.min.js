function identicalNumArray(a,b){return a.reduce((prev,curr,i)=>prev&&curr==b[i],!0)}function indexOfNumArray(fromArray,findArray){return fromArray.findIndex(x=>identicalNumArray(x,findArray))}function cyclicOrder(m,from,end=-1,direction="cw"){let arr=Array.from(Array(m).keys(),i=>i+1);return arr=[...arr.slice(from-1),...arr.slice(0,from-1)],-1!=end&&(arr=arr.slice(0,arr.indexOf(end))),"cw"==direction?arr:arr.reverse()}function cyclicCompare(a,b,order){return order.indexOf(a)-order.indexOf(b)}function isCyclicChain(chain,m,order=null,strict=!1){let diff;return null!=order?m=order.length:order=cyclicOrder(m,chain[0]),chain.map(x=>order.indexOf(x)).reduce((isInc,current,i,diff)=>0==i||isInc&&(current-diff[i-1]>=strict?1:0),!0)}function isCyclicIntervalsNonCrossing(a,b,m){let order=cyclicOrder(m,a[0]);return!(isCyclicChain([a[0],b[0],a[1],b[1]],m,order)||isCyclicChain([a[0],b[1],a[1],b[0]],m,order))}class DiskModel{log;algebra;valencies;dualVals;arcsys;dissection;constructor({kupisch:kupisch=[],logger:logger=null,diskmodel:diskmodel=null}={kupisch:[]}){this.log=null===logger?new Logger:logger,kupisch.length>1?this.arcSysFromKupisch(kupisch):null!==diskmodel?(Object.assign(this,diskmodel),this.algebra=new LNakayama({logger:this.log,data:diskmodel.algebra})):this.log.add("‼ Error in constructing disk model.")}static valenciesFromKupisch(kup,dual=!1){if(kup.length<2)return[1,1];for(var changes=[1],i=1;i<kup.length;)dual?kup[i-1]>kup[i]&&changes.push(i+1):kup[i-1]>kup[i]||changes.push(i+1),i++;dual||changes.push(kup.length);var diff=[],valencies=[];for(i=1;i<changes.length;i++){let d=changes[i]+1-changes[i-1];valencies.push(d),diff.push(d-2)}for(diff[0]++,diff[diff.length-1]++,i=diff.length-1;i>=0;i--)valencies=valencies.concat(Array(diff[i]).fill(1));return dual||valencies.reverse(),valencies}static valenciesToArcs(vals){let j=vals.length-1,i=1,arcs=[];for(arcs.push([1,vals.length]);vals[j]>1;){for(let k=i;k-i<vals[j]-2;k++)arcs.push([k+1,j+1]);arcs.push([j,j+1]),i+=vals[j]-2,j--}return arcs}static valenciesToDualArcs(vals){let revVals=[...vals].reverse(),arcs=this.valenciesToArcs(revVals),n=vals.length;return arcs.map(a=>[n+1-a[1],n+1-a[0]])}arcSysFromKupisch(kup){this.algebra=new LNakayama({kupisch:kup,logger:this.log}),this.algebra.isGentle?this.log.add("✔ Dissection and dual arc system."):this.log.add("❌ Input algebra is not gentle LNakayama."),this.dualVals=this.constructor.valenciesFromKupisch(kup,!0),this.m=this.dualVals.length,this.log.add(`✔ Valencies of red pts: [ ${this.dualVals} ]`);let unordArcSys=this.constructor.valenciesToDualArcs(this.dualVals),arcsys=[unordArcSys[0]];unordArcSys=unordArcSys.slice(1);let endpt=1;for(;unordArcSys.length>0;){let t=[],sameEndpt=[];for(let x of unordArcSys)(x[0]==endpt?sameEndpt:t).push(x);sameEndpt=sameEndpt.sort(([,x1],[,y1])=>y1-x1);for(let y of sameEndpt)arcsys.push(y);unordArcSys=t,endpt=arcsys[arcsys.length-1][1]}this.arcsys=arcsys,this.log.add(`✔ Dual arc system: [ ${arcsys} ]`),this.valencies=this.constructor.valenciesFromKupisch(kup),this.log.add(`✔ Valencies of green pts: [ ${this.valencies} ]`);let unordLams=this.constructor.valenciesToArcs(this.valencies),lams=[[1,this.m]];for(let i=1;i<arcsys.length;i++){let lam;lam=1==this.dualVals[arcsys[i][0]-1]?[arcsys[i][0],arcsys[i][0]+1]:1==this.dualVals[arcsys[i][1]-1]?[arcsys[i][1],arcsys[i][1]+1]:unordLams.filter(l=>l[0]==arcsys[i][1]||l[1]==arcsys[i][1])[0],lams.push(lam)}return this.dissection=lams,this.log.add(`✔ Dissection: [ ${lams} ]`),arcsys}resetLog(){this.log=new Logger}static nextArc(arcIdx,arcs,direction="ccw"){let arc=arcs[arcIdx],otherEnd=arc[0]==endpt?arc[1]:arc[0],nextpt="ccw"==direction?otherEnd-1>=1?otherEnd-1:m:otherEnd+1<=m?otherEnd+1:1,nextarc=endpt<nextpt?[endpt,nextpt]:[nextpt,endpt],idx=indexOfNumArray(arcs,nextarc);for(;-1==idx&&nextpt!=endpt;)nextpt="ccw"==direction?nextpt-1>=1?nextpt-1:m:nextpt+1<=m?nextpt+1:1,nextarc=endpt<nextpt?[endpt,nextpt]:[nextpt,endpt],idx=indexOfNumArray(arcs,nextarc);return nextpt!=endpt?arcs[idx]:-1}moduleToLaminate(M){let dualarcs=this.arcsys?this.arcsys:this.dualArcSys(),projres=this.algebra.projRes(M);if(this.log.add(`Module [${M}] has proj.res: 0 <- P${projres.join(" <- P")} <- 0.`),1==projres.length)return this.log.add(` -> laminate [${this.dissection[projres[0]-1]}]`),this.dissection[projres[0]-1];{let idx1=projres[0],idx2=projres[projres.length-1],lams=[this.dissection[idx1-1],this.dissection[idx2-1]],orders=[],[x1,x2]=dualarcs[idx1-1],[y1,y2]=dualarcs[idx2-1];isCyclicChain([x1,x2,y1,y2],this.m)?orders=[[x1,x2],[y1,y2]]:isCyclicChain([x2,x1,y1,y2],this.m)?orders=[[x2,x1],[y1,y2]]:this.log.add("❌ Something wrong in the ordering of arcs' endpoints.");let endpts=orders.map((o,i)=>isCyclicChain([2*o[0],2*lams[i][0]-1,2*o[1]],2*this.m,null,!0)?lams[i][0]:lams[i][1]);return this.log.add(` -> laminate [${endpts}]`),endpts[0]<endpts[1]?endpts:[endpts[1],endpts[0]]}}}function oppositeGreenMkpt(arcIdx,vsArcIdx,arcSys,m,dualVals,greenMkpts=null){if(arcSys[arcIdx]==[1,m])return 1;if(arcSys[arcIdx][1]-arcSys[arcIdx][0]==1)return arcSys[arcIdx][1];greenMkpts||(greenMkpts=dissectionFromArcSys(arcSys,m,dualVals));let pair=greenMkpts[arcIdx],order=cyclicOrder(m,arcSys[arcIdx][0]);return order=order.slice(0,order.indexOf(arcSys[arcIdx][1])+1),pair=-1==order.indexOf(pair[0])?[pair[1],pair[0]]:pair,arcSys[arcIdx][0]<arcSys[vsArcIdx][0]&&arcSys[vsArcIdx][1]<arcSys[arcIdx][1]?pair[1]:pair[0]}
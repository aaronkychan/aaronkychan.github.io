let talks = [
    {
        ymd: "2025-10-20",
        start: "1630",
        duration: 90,
        title: "Finiteness and tameness of Jacobian algebras",
        speaker: "Toshiya Yurikusa 百合草 寿哉",
        affil: "Osaka Metropolitan University 大阪公立大学",
        abstract: `<p>本講演では、有限次元ヤコビ代数をその表現型の観点から研究し、$E$不変量によって定義される$E$有限性および$E$-tame性と、$g$有限性、$\\tau$傾有限性、表現有限性などの他の有限性・tame性の概念との対応について述べる。</p>

<p>まず、これらの性質がクイバーとポテンシャルの変異の下で不変であることを示す。その結果として、有限次元ヤコビ代数$\\mathcal{J}(Q,W)$が$E$有限であることは、$g$有限、$\\tau$傾有限、表現有限であることと同値であり、この場合には
$Q$がDynkin型であることが分かる。この結果は、Demonetの「$E$有限なら$g$有限である」という予想を含む形で成立している。</p>

<p>また、$E$-tame性に関しては、例外的な3つの型を除いて、$g$-tame性および表現tame性と対応することが分かる。本講演は、Mohamad
Haerizadeh氏との共同研究に基づくものである。</p>`,
        lang: "jp",
        access: { id: "829 2845 2592", psw: "265160" },
        // record: {
        //     slides: "TNA/2025/Yurikusa-Finite_Tame_Jacobian_Algebras.pdf",
        // },
    },
    {
        ymd: "2025-08-19",
        start: "1500",
        duration: 90,
        title: "自己入射的代数のCartan行列の正定値性と$\\tau$-傾有限性",
        speaker: "Naoya Hiramae 平前 直也",
        affil: "Kyoto University 京都大学",
        abstract: `有限次元代数の$\\tau$-傾有限性は，ねじれ対の関手的有限性やbrickの有限性，さらには$g$-扇の完備性や準傾複体の連結性などといった表現論において重要な性質と密接に関係しており，昨今さかんに研究されている．有限群のモジュラー表現論（＝正標数体上の群環の加群論）の文脈では，正標数$p$の代数閉体$k$と有限群$G$に対して，群環$kG$の$\\tau$-傾有限性は$G$の$p$-超焦点部分群によって決まるのではないかと予想されており（[Hiramae-Kozakai,
2025]），これは群環$kG$の表現型が$G$の$p$-Sylow部分群によって決定されるという古典的な結果の類似である．本講演ではまず自己入射的代数の$\\tau$-傾有限性とCartan行列の正定値性の関係について説明し，その応用例としてある半直積群の群環に対して上の予想が成り立つことを示す．
`,
        lang: "jp",
        access: { id: "825 9241 0495", psw: "699837" },
        record: {
            slides: "TNA/2025/Hiramae-PosDefCartan_of_selfinj_algebras_and_tau-finiteness.pdf",
        },
    },
    {
        ymd: "2025-07-15",
        start: "1530",
        duration: 90,
        title: "super category $\\mathcal{O}$におけるsemibrick",
        speaker: "Shunsuke Hirota 廣田 竣介",
        affil: "Kyoto University 京都大学",
        abstract: `標数0の閉体上で、双対余根基可換な有限次元basic Hopf代数の分類は、"本質的に異なる基底の取り方を許すroot系"または"Conway-Coxeterのfrieze patternの高階版"ともいえる、Heckenberger-山根(2008)のWeyl groupoidがよく説明する。Weyl groupoidの少なくないクラスはKac-Moody Lie超代数から来る。古典的category $\\mathcal{O}$は最高ウェイト圏の代表的な例とされるが、super category $\\mathcal{O}$は複数の最高ウェイト構造を備えた圏の好例と考えられ、homの記述が容易な加群であるVerma加群がある意味多数存在することによりsemibrickが自然に生じ易い。本講演では、semibrickの概念なしに定式化し難い初歩的な結果や、super category $\\mathcal{O}$のホモロジー代数的な側面を紹介したい。`,
        lang: "jp",
        access: { id: "815 5125 0164", psw: "952236" },
        record: {
            slides: "TNA/2025/Hirota-Semibricks_in_super_category_O.pdf",
        },
    },
    {
        ymd: "2025-07-08",
        start: "1030",
        duration: 90,
        title: "On the Auslander—Reiten theory for extended hearts of proper connective DG-algebras",
        speaker: "Nao Mochizuki 望月 直央",
        affil: "Nagoya University 名古屋大学",
        abstract: `<p>本講演では, proper connective DG代数の$d$-extended heartにおけるAuslander-Reiten理論 を紹介する. 講演の主な対象となる$d$-extended heartsは, コホモロジーが次数$0$から$-d+1$の間に集中するような DG加群からなる導来圏の部分圏である. 特に, 有限次元代数の場合，$1$-extended heart は, 通常の有限生成加群圏に一致する.</p>
<p>本講演では，この有限生成加群圏におけるAuslander-Reiten理論が, $d$-extended hearts を用いることで proper connective DG代数の文脈にまで一般化されることを紹介する. また, DG-quiverから構成されるDG代数に対するAR-quiverの具体的な計算例も併せて紹介する.</p>`,
        lang: "jp",
        access: { id: "870 3048 1997", psw: "392212" },
        record: {
            slides: "TNA/2025/Mochizuki_Nao-AR_theory_for_extended_hearts.pdf",
        },
    },
    {
        ymd: "2025-06-10",
        start: "1530",
        duration: 90,
        title: "Generic decompositions of g-vectors",
        speaker: "Mohamad Haerizadeh",
        affil: "Univeristy of Tehran",
        abstract: `<p>In this talk, we discuss the role of g-vectors in the representation
theory of algebras. Specifically, we describe how generic
decompositions of g-vectors yield decompositions of generically
$\\tau$-reduced components of representation varieties and vice versa. This
connection allows us to provide a partial answer to the
Cerulli-Labardini-Schröer conjecture concerning the number of direct
summands of generically $\\tau$-reduced components of representation
varieties.</p>
<p>
Furthermore, we examine the cones of g-vectors, demonstrating that
they are both rational and simplicial. We establish that $g$-vectors
satisfy the ray condition if they are sufficiently far from the
origin. These results enable us to generalize several results by Asai
and Iyama concerning TF-equivalence classes of g-vectors. Therefore,
our consequences can be utilized to study the wall and chamber
structures of finite-dimensional algebras.  This is joint work with Siamak Yassemi.</p>`,
        lang: "en",
        access: { id: "844 4810 7612", psw: "275169" },
        record: {
            slides: "TNA/2025/Haerizadeh-GenericDecomp_gvec.pdf",
        },
    },
    {
        ymd: "2025-05-12",
        start: "1530",
        duration: 90,
        title: "Auslander近似理論を用いたMartsinkovsky不変量へのアプローチ",
        speaker: "Yuya Otake 大竹 優也",
        affil: "Nagoya University 名古屋大学",
        abstract: `Auslander-Buchweitz理論、あるいはAuslander-Bridger理論は、Gorenstein環上のいかなる有限生成加群も（極大）Cohen-Macaulay加群による近似（CM近似）を持つことを保証する。Auslanderは1987年にMSRIで開かれた可換環論Berkeleyシンポジウムにて、可換Gorenstein局所環上のCM近似の極小性について講演し、極小CM近似の一意存在性を述べた。さらにこの極小CM近似を用いて可換Gorenstein局所環上の有限生成加群に対しデルタ不変量なる整数量を定め、デルタ不変量0を持つ加群の著しい性質について講演したようである。上述した内容が記されたAuslanderの論文はついぞ公表されることはなかったが、数多の研究者の貢献によりデルタ不変量にはイデアル論・表現論の両側面から深い理論が構築され、また応用が見出されている。他方、1990年代後半、MartsinkovskyはGorensteinとは限らない一般の可換ネーター局所環上にグザイ不変量なる新しい量を定義し、それがデルタ不変量と多くの性質を共有する事、並びにGorenstein環上ではデルタ不変量と一致する事を証明した。グザイ不変量の理論の構築にあたりMartsinkovskyがとったアプローチは自由分解が持つ微分次数構造の精緻な解析に基づくが、この講演ではグザイ不変量に収束する非減少数列を考え、その各項をAuslander近似理論により記述するアプローチについて述べる。そのために、講演の前半では可換とは限らない一般のネーター環上のAuslanderの近似理論について詳説する。後半では同近似理論と安定圏の手法を用いて近似グザイ不変量の評価を与え、AuslanderやMartsinkovskyによる諸定理がどのように回復されるかをみる。`,
        lang: "jp",
        access: {
            id: "894 5567 7050",
            psw: "885666",
        },
        record: {
            slides: "TNA/2025/Otake_Yuya-Martsinkovsky_invariant.pdf",
        },
    },
    {
        ymd: "2025-05-07",
        start: "1300",
        duration: 90,
        title: "Autoequivalences of triangulated categories via Hochschild cohomology",
        speaker: "Sebastian Opper",
        // web: "https://pas201.user.srcf.net/",
        affil: "Universeity of Tokyo 東京大学",
        abstract:
            'I will talk about a general tool which allows one to study symmetries of (enhanced) triangulated categories in the form of their derived Picard groups. In general, these groups are rather elusive to computations which require a rather good understanding of the category at hand. A result of Keller shows that the Lie algebra of the derived Picard group of an algebra can be identified with its Hochschild cohomology equipped with the Gerstenhaber Lie bracket. Mimicking the classical relationship between Lie groups and their Lie algebras, I will explain how to "integrate" elements in the Hochschild cohomology of a dg category over fields of characteristic zero to elements in the derived Picard group via a generalized exponential map. Afterwards we discuss properties of this exponential and a few applications. This includes necessary conditions for the uniqueness of enhancements of triangulated functors and uniqueness of Fourier-Mukai kernels. Other applications concern derived Picard groups of categories arising in algebra and geometry: derived categories of graded gentle algebras and their corresponding partially wrapped Fukaya categories or stacky nodal curves as well as Fukaya categories of cotangent bundles and their plumbings.',
        lang: "en",
        access: {
            id: "822 3531 1702",
            psw: "596657",
        },
        // record: {
        //     slides: "https://pas201.user.srcf.net/documents/2025-utokyo-slides",
        // },
    },
    {
        ymd: "2025-04-15",
        start: "1030",
        duration: 90,
        title: "Torsion pairs for McKay quivers",
        speaker: "Parth Shimpi",
        web: "https://pas201.user.srcf.net/",
        affil: "Glasgow",
        abstract:
            "Classifying torsion classes in the module category has been a problem\nof much interest in the representation theory of preprojective\nalgebras, owing to its immediate applications in the study of\nt-structures, bricks, and spherical objects in the derived category.\nWhen the preprojective algebra arises from a Dynkin quiver, all such\ntorsion classes must lead to algebraic intermediate hearts— in\nparticular, they arise from tilting modules and therefore admit a\nfinite combinatorial description. Affine ADE quivers, on the other\nhand, produce infinitely many tilting modules and moreover have\ngeometric hearts arising from the McKay correspondence. By realising\nthe geometric hearts as `limits’ of algebraic ones, I will explain how\nall torsion pairs for affine preprojective algebras can be described\nusing the above two possibilities; in particular a complete\nclassification is achieved.",
        lang: "en",
        access: {
            id: "813 0345 0035",
            psw: "706679",
            hybrid: "Rm 128, <a href='https://www.ms.u-tokyo.ac.jp/access/index.html'>Graduate School of Mathematics, University of Tokyo</a>",
        },
        record: {
            slides: "https://pas201.user.srcf.net/documents/2025-utokyo-slides",
        },
    },
    {
        ymd: "2025-04-02",
        start: "1030",
        duration: 90,
        title: "因子類群が$\\mathbb{Z}^2$であるトーリック環の非可換クレパント特異点解消について",
        speaker: "Koji Matsushita 松下光虹",
        affil: "Universeity of Tokyo 東京大学",
        abstract:
            "<p>トーリック環上で定義されるconic因子的イデアルは非常に良い可換環論的性質を満たしている一方で、代数幾何や表現論など、可換環論にとどまらない様々な分野で重要な役割を担っている。\n実際、全てのconic因子的イデアルの直和の自己準同型環が、元のトーリック環の非可換特異点解消(NCR)になることが知られている。そのことから、これがそのまま非可換クレパント特異点解消(NCCR)になるかどうかを考えるのは自然であるが、多くの場合、NCCRにはならない。そこで、全てではなく、一部のconic因子的イデアルを抽出することでNCCRが構成できるかどうかを見る。例えば、因子類群が$\\mathbb{Z}$であるようなGorensteinトーリック環の場合は上手くconic因子的イデアルを選ぶことでNCCRを構成できるが、$\\mathbb{Z}^2$である場合で、どのようにconic因子的イデアルを選んでもNCCRを成さないようなGorensteinトーリック環が存在することが知られている。こういった状況を踏まえ、どのようなトーリック環がNCCRを持つのか、また、どのようにconic因子的イデアルを選べばNCCRを構成できるのかを考えるのは自然な問題となる。</p>\n\n<p>\n本講演ではトーリック環のconic因子的イデアルを用いたNCCRの構成について知られていることについて整理したのち、因子類群が$\\mathbb{Z}^2$であるGorensteinトーリック環がNCCRを持つための条件について、講演者が得た結果を紹介する。</p>",
        lang: "jp",
        access: {
            id: "861 6231 1607",
            psw: "593942",
        },
        record: {
            slides: `TNA/2025/Matsushita_Koji-Toric_Ring_NCCR.pdf`,
        },
    },
    {
        ymd: "2025-03-27",
        start: "1030",
        duration: 90,
        title: `Reduction理論における変異が誘導する三角圏構造`,
        speaker: "Ryota Iitsuka 飯塚 亮太",
        affil: "Nagoya University 名古屋大学",
        // web: `https://lmbp.uca.fr/~riche/`,
        abstract: `準傾部分圏、$n$-団傾部分圏、単純系や $n$-simple-minded
systemの変異は三角圏構造を誘導することが知られている。この三角圏構造は,
変異で不変な部分を「潰すこと(reduction)」で得られる。また、潰す前の圏における変異は、潰した後に得られる三角圏のシフト関手を定める。そのためこの結果は、準傾部分圏などの特別な部分圏(または単純系などの特別な対象の集まり)が変異で保たれることを示す際に、重要な役割を果たした(いわゆるreduction理論)。しかしその一方で、それぞれの変異は独立に定義されており、それらの変異が三角圏構造を誘導するという結果も独立に示されていた。

本公演では、準傾部分圏、$n$-団傾部分圏、単純系や $n$-simple-minded system
の変異を共通一般化した枠組みである「reducible triple」を導入する。Reducible
tripleがまさに既に紹介した4つの変異の例を一般化した概念になっていること、reducible
tripleが定める変異は三角圏構造を誘導することを紹介する予定である。また、mutation
tripleとの関連性についても紹介したいと考えている。`,
        lang: "jp",
        access: {
            id: "871 6340 9751",
            psw: "381921",
        },
        record: {
            slides: `TNA/2025/Iitsuka-Triangulated_structure_from_reduction.pdf`,
        },
    },
    {
        ymd: "2025-03-17",
        start: "1430",
        duration: 90,
        title: `On Amiot's conjecture`,
        speaker: "Junyang Liu",
        affil: "University of Science and Technology of China",
        // web: `https://lmbp.uca.fr/~riche/`,
        abstract: `In 2010, Claire Amiot conjectured that algebraic
2-Calabi-Yau categories with cluster-tilting object must come from
quivers with potential. This would extend a structure theorem obtained
by Keller-Reiten in the case where the endomorphism algebra of the
cluster-tilting object is hereditary. Many other classes of examples
are also known. We will report on the proof of the conjecture in the
general case for categories with *algebraic* 2-Calabi-Yau structure.
This result has been obtained in joint work with Bernhard Keller and
is based on Van den Bergh's structure theorem for complete Calabi-Yau
algebras. We also generalize his structure theorem to the relative
case and use it to prove a relative variant of the conjecture.`,
        lang: "en",
        access: {
            id: "853 1951 5047",
            psw: "900788",
        },
        record: {
            slides: [
                `TNA/2025/LiuJungyang-GinzburgMorphism.pdf`,
                `TNA/2025/LiuJungyang-AmiotConjecture.pdf`,
            ],
        },
    },
];

//#region Code starts
let talkList = "",
    pastList = "";

let docTalkList = document.getElementById("talkList");
let docPastList = document.getElementById("pastList");

//const defaultStartTime = ["10", "30"];
const daysString = [
    "Sun 日",
    "Mon 月",
    "Tue 火",
    "Wed 水",
    "Thu 木",
    "Fri 金",
    "Sat 土",
    "Sun 日",
];

// ***** Determine time offset
const ourZone = "Asia/Tokyo";
//const ourZone = "Asia/Pyongyang";
//const ourZone = "Europe/Paris";
//const ourZone = "America/New_York";
let localtime = luxon.DateTime.local();
let ourtime = localtime.setZone(ourZone);
const sameTime = ourtime.offset == localtime.offset;
if (ourZone !== localtime.zoneName) {
    document.getElementById(
        "timeInfo"
    ).innerHTML = `<p>Date/time are displayed in your timezone (<b>${localtime.zoneName}, ${localtime.offsetNameShort}</b>).<br/>
    Our timezone is ${ourZone} (${ourtime.offsetNameShort})</p>`;
}

const expandToArr = (val, len) =>
    Array.isArray(val) ? val : Array(len).fill(val);
const isISODate = (d) =>
    d.match(/^\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$/);
/**
 * @param  {string} date (in ISO format "yyyy-mm-dd")
 * @param  {string} start (4 character string "hhmm", or empty)
 */
const toDateTimeObj = (date, start) => {
    let timeSubstr =
        start !== "" ? `${start.slice(0, 2)}:${start.slice(2, 4)}` : "13:00";
    return luxon.DateTime.fromISO(`${date}T${timeSubstr}:00`, {
        zone: ourZone,
    });
};
/**
 *
 * @param {luxon.DateTime} dt - luxon DateTime object
 */
const simpleISOTime = (dt) =>
    dt.toISOTime({
        suppressSeconds: true,
        includeOffset: false,
    });
/**
 * @param  {luxon.DateTime} DT
 * @param  {boolean} hasStart
 * @param  {int} duration
 * @param  {string} zone adjust DT to zone
 */
function getDTString(DT, hasStart, duration, zone) {
    let t = zone !== ourZone ? DT.setZone(zone) : DT; //adjust start time if needed
    let day = zone !== ourZone ? t.toFormat("EEE") : daysString[t.weekday];

    let endt = t.plus({ minutes: duration });
    let spant = hasStart
        ? `${simpleISOTime(t)} ~ ${
              endt.hasSame(t, "day") ? "" : "+1day "
          }${simpleISOTime(endt)}`
        : `Time TBC`;

    return `${t.toISODate()} (${day}) ${spant}`;
}

function timeDataToHTML(ymd, start, duration) {
    let str = "",
        inSchedule = true;
    if (isISODate(ymd)) {
        let hasStart = start !== "" && start !== "TBC";
        let dt = toDateTimeObj(ymd, hasStart ? start : "");
        str = getDTString(
            dt,
            hasStart,
            duration,
            sameTime ? ourZone : localtime.zoneName
        );

        inSchedule = localtime.valueOf() <= dt.plus({ minutes: 30 }).valueOf();
        str +=
            sameTime || !inSchedule
                ? ""
                : ` <span style='color:#D0D0D0;'>[<abbr title=" ${getDTString(
                      dt,
                      hasStart,
                      duration,
                      ourZone
                  )} "> In our time: </abbr>]</span>`;
    } else {
        str = ymd;
    }
    return [str, inSchedule];
}

//#region Page Generation
// ***** Actual page generation starts here
for (let talk of talks) {
    let str = `<fieldset ${
        "id" in talk ? 'id="' + talk.id + '"' : ""
    }><legend>`;
    let inSchedule = true;
    if (Array.isArray(talk.ymd)) {
        let startArr = expandToArr(
            "start" in talk ? talk.start : "",
            talk.ymd.length
        );
        let durArr = expandToArr(
            "duration" in talk ? talk.duration : 90,
            talk.ymd.length
        );
        let lastTalk = [
            talk.ymd.slice(-1)[0],
            startArr.slice(-1)[0],
            durArr.slice(-1)[0],
        ];
        inSchedule = timeDataToHTML(lastTalk[0], lastTalk[1], lastTalk[2])[1];
        let lines = [];
        for (let [i, ymd] of talk.ymd.entries()) {
            let [s, isFuture] = timeDataToHTML(ymd, startArr[i], durArr[i]);
            s =
                isFuture || !inSchedule
                    ? `Talk ${i + 1}: ${s}`
                    : `<span style='color:#D0D0D0;text-decoration: line-through;'>Talk ${
                          i + 1
                      }: ${s} </span>`;
            lines.push(s);
        }
        str += lines.join("<br/>");
        str += `</legend>`;
    } else {
        let [s, b] = timeDataToHTML(
            talk.ymd,
            "start" in talk ? talk.start : "",
            "duration" in talk ? talk.duration : 90
        );
        inSchedule = b;
        str += `${s}</legend>`;
    }

    // start piecing data entry
    str += `<ul class="twocolumns left80 leftbold">`;
    str += `<li><div class="leftcolumn">Title:</div><div class="maincolumn">${talk.title}</div></li>`;
    let affilString = "affil" in talk ? ` (${talk.affil})` : "";
    let spString =
        "web" in talk
            ? `<a href=${talk.web}>${talk.speaker}${affilString}</a>`
            : `${talk.speaker}${affilString}`;
    str += `<li><div class="leftcolumn">Speaker:</div><div class="maincolumn">${spString}</div></li>`;
    str += `<li><div class="leftcolumn">Abstract:</div><div class="maincolumn">${talk.abstract}</div></li>`;
    str += `<li><div class="leftcolumn">Language:</div><div class="maincolumn">${
        talk.lang === "jp" ? "Japanese 日本語" : "English"
    }</div></li>`;
    if ("access" in talk) {
        let linkurl =
            "link" in talk.access
                ? talk.access.link
                : "id" in talk.access
                ? `https://u-tokyo-ac-jp.zoom.us/j/${talk.access.id.replaceAll(
                      /[\s\xA0\uFEFF\u180E\u2000-\u200A\u202F\u205F\u3000]+/g,
                      ""
                  )}`
                : "";

        let hybridInfo =
            "hybrid" in talk.access
                ? "Hybrid meeting at " + talk.access.hybrid + "<br>"
                : "";
        // console.log(hybridInfo);
        let label = "custom" in talk.access ? talk.access.custom : "Zoom";
        let accessString =
            hybridInfo +
            (inSchedule
                ? linkurl.length > 1
                    ? `[&nbsp;<a href="${linkurl}" target="_blank">${label}</a>&nbsp;]&nbsp;`
                    : label
                : `Meeting ended `);

        accessString +=
            "customInfo" in talk.access ? talk.access.customInfo : "";

        accessString +=
            "id" in talk.access
                ? `<b>Zoom ID</b>&nbsp;${talk.access.id}&nbsp;`
                : ``;

        accessString +=
            "psw" in talk.access
                ? `<b>Password</b>&nbsp;${talk.access.psw}&nbsp;`
                : "";

        str +=
            accessString === ""
                ? ""
                : `<li><div class="leftcolumn">Access:</div><div class="maincolumn">${accessString}</div></li>`;
    }

    if ("record" in talk) {
        str += `<li><div class="leftcolumn">Record:</div><div class="maincolumn">`;
        if ("slides" in talk.record) {
            let multiple = Array.isArray(talk.record.slides);
            let slidesArr = multiple
                ? talk.record.slides
                : [talk.record.slides];
            let sdArr =
                "slidesDesc" in talk.record
                    ? Array.isArray(talk.record.slidesDesc)
                        ? talk.record.slidesDesc
                        : [talk.record.slidesDesc]
                    : new Array(slidesArr.length).fill("");
            sdArr[0] = multiple || sdArr[0] != "" ? sdArr[0] : "Slides";
            let out = slidesArr.map((s, i) => {
                let desc = sdArr[i] === "" ? `Slides ${i + 1}` : sdArr[i];
                return s === "contact"
                    ? "Contact speaker for slides. "
                    : `<a href="${s}">${desc}</a>`;
            });
            str += out.join(" ; ");
            str += ".";
        } else {
            str += "No slide will be made available. ";
        }
        if ("vid" in talk.record) {
            str += "&nbsp;&nbsp;";
            let desc =
                "desc" in talk.record.vid
                    ? talk.record.vid.desc
                    : `Link to video`;
            desc =
                desc === "request"
                    ? `Video recording can be provided upon request.`
                    : desc;
            str +=
                "url" in talk.record.vid
                    ? `<a href="${talk.record.vid.url}">${desc}</a>`
                    : desc;
        }
        //str += ("vid" in talk.record)?`<a href="${talk.record.vid}">Video</a>. `:"Video not available.";
        str += `</div></li>`;
    }
    str += `</ul></fieldset>`;

    inSchedule ? (talkList = str + talkList) : (pastList += str);

    // for producing pastlist as HTML without compiling KaTex
    // console.log(pastList);

    docTalkList.innerHTML = `<p>Loading talks...</p>` + talkList;
    docPastList.innerHTML = `<p>Loading talks...</p>` + pastList;
}

docTalkList.innerHTML = talkList;
docPastList.innerHTML = pastList;
// console.log(MathJax);
// MathJax.typeset();

/*** Smooth scroll shortcut ***/
function smScroll(to) {
    let y = document.getElementById(to).offset - 5;
    window.scrollTo({ top: y, behaviour: "smooth" });
}

/****  Scroll to top ****/
//Get the button:
btnToTop = document.getElementById("btnToTop");

// When the user scrolls down 20px from the top of the document, show the button
window.addEventListener("scroll", () => {
    if (
        document.body.scrollTop > 20 ||
        document.documentElement.scrollTop > 20
    ) {
        btnToTop.style.display = "block";
    } else {
        btnToTop.style.display = "none";
    }
});

let scrollToPos = document.getElementById("sec:schedule").offsetTop - 10; //give 10px padding to top
btnToTop.addEventListener("click", () => {
    window.scrollTo({ top: scrollToPos, behavior: "smooth" });
});

document.addEventListener(`click`, (e) => {
    if (e.target.tagName.toLowerCase() === "a") {
        //e.preventDefault();
        //console.log(`You clicked ${e.target.href}`);
        let anc = e.target.href.split("#").pop();
        let elt = document.getElementById(anc);
        if (elt.classList.contains("highlighted")) {
            elt.classList.remove("highlighted");
        }
        elt.classList.add("highlighted");
        elt.addEventListener("animationend", () => {
            elt.classList.remove("highlighted");
        });
    }
});

//#region Notes for json data
/* FOR COPY AND PASTE:
{ 
    ymd: "2000-01-01",
    start: "1600",
    duration: "90",
    title: "TBC",
    speaker: "ABC Suzuki",
    web: "http://www.math.nagoya-u.ac.jp/"
    affil: "Nagoya",
    abstract: "TBC",
    lang: "jp",
    access: {"id": "123&nbsp;345&nbsp;6789", "psw":"4321", 
            "link":"http://www.math.nagoya-u.ac.jp", 
            "hybrid": "Hybrid meeting information",
            "custom": "SEE HERE"}
    record: {"slides" : "Contact speaker/link", "vid": "link"}
}
*/

/*
data structure:  
"ymd": "YYYY-MM-DD",  can be an array for lecture series
"id": string  (use if need anchoring)
"start": "hhmm" 24hr format  (NOTE: this is in Asia/Tokyo timezone), can be array for lecture series
"duration": optional number representing duration in mintue (default to 90, i.e. 1.5hr), can be array for lecture series
"title": string
"speaker": string
"web": string (to speaker's webpage)
"affil": optional (speaker affiliation)
"abstract": string possibly with HTML code
"lang": optional (default to "en") can only take "en" or "jp" for now
"access": { "id": string, "psw": string, "link": string, "custom": string }  all entry optional (leave blank = TBC)
"record": { "slides": string ("contact" or provide link), "vid": string (provide link, leave blank = display "No video recorded" } (leave blank = don't display)

about array form:
Example
{
    ymd: ["2023-12-25", "2023-12-25"],
    start: ["1030", "1445"],
    ...
}

about acess data:
id, psw = zoom id/zoom psw
link = provide link (anchor to custom text)
custom = any string for extra info (can be HTML)

Example of hardcoding zoom info into custom:
access: {
    custom: ` ~Hybrid~<br> `,
    customInfo: `&nbsp;<b>Online</b>: <a href="https://u-tokyo-ac-jp.zoom.us/j/87435810573">Zoom</a> <b>ID</b> 874 3581 0573 <b>Password</b> 957963 <br>&nbsp;<b>Location</b>: 東京大学大学院数理科学研究科 002号室<br/>&nbsp;Graduate School of Mathematical Science Room 002, University of Tokyo`,
}
            

***** 1st entry of array  = NEWEST TALK *******
*/

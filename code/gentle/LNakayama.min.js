class LNakayama{kupisch=[2,1];rank=2;isGentle=!0;log;relations=[];projs=[];injs=[];qhsPoset=[];qhsPosetPartitioned=[];indecs=[];gldim=0;constructor({kupisch:kupisch=[],logger:logger=null,data:data=null}={kupisch:[]}){if(null!==data)Object.assign(this,data),this.log=null==logger?new Logger:logger;else{if(this.log=null==logger?new Logger:logger,!this.isLNakayama(kupisch))return this.log;this.kupisch=kupisch,this.rank=kupisch.length,this.relations=this.computeRelations(),this.isGentle=this.relations.reduce((prev,curr)=>prev&&curr[1]-curr[0]==2,!0),this.log.add(`Loaded ${this.isGentle?"":"non-"}gentle LNakayama of rank ${this.rank}.`),this.projs=kupisch.map((l,i)=>[i+1,i+l]),this.injs=Array.from(Array(this.rank).keys()).map(i=>{let j=i;for(;j>=0;){let top=this.relations.filter(r=>r[1]==j);if(top.length>0)return[top[0][0]+2,i+1];j--}return[1,i+1]}),this.gldim=Math.max(...this.projs.map(P=>this.pdim([P[0],P[0]]))),this.log.add(`gldim(A)=${this.gldim}`),this.indecs=this.projs.map((_,i)=>[...Array(kupisch[i]).keys()].map(j=>[i+1,i+1+j])).flat(),this.log.add(`| indec(A) | = ${this.indecs.length}`)}}isValidKupisch(kup){let test=kup.length>1,i=0;for(;test&&i<kup.length-1;)test=kup[i+1]>=kup[i]-1&&kup[i]-1>=1,i++;return test=test?kup[1]>=kup[kup.length-1]-1:test,test}static kupischFromZComposition(zcomp){let res=zcomp.map(a=>new Array(a).fill(0).map((_,j)=>a+1-j));return res.push(1),res.flat()}resetLog(){this.log=new Logger}isLNakayama(kup){if(this.isValidKupisch(kup)){if(1==kup[kup.length-1])return!0;this.log.add("Not LNakayama")}else this.log.add("Not a valid Kupisch series");return!1}isGentle(){return this.isGentle=(this.relations?this.relations:this.computeRelations()).reduce((prev,curr)=>prev&&curr[1]-curr[0]==2,!0),this.isGentle}gentleZComposition(){if(this.isGentle){let res=ArraySplit(this.kupisch,2).slice(0,-1).map(x=>x.length>0?x[0]-1:1);return this.log.add(`Integer composition corresponding to gentle structure: [${res}]`),res}return this.log.add("Not gentle => no integer composition."),!1}computeRelations(){let rels=[];for(let i=0;i<this.rank-2;i++)this.kupisch[i]-1!=this.kupisch[i+1]&&rels.push([i,i+this.kupisch[i]]);return this.relations=rels,this.relations.length>0?this.log.add(`Relations [src vx,tgt vx]: ${JSON.stringify(rels)}`):this.log.add("Quiver algebra with no relation"),rels}isModule(M){return M[0]<=M[1]&&M[0]>=1&&M[1]<=this.rank&&M[1]-M[0]<this.kupisch[M[0]-1]}syzygy(M){let syzygyLen=this.kupisch[M[0]-1]-(M[1]+1-M[0]);return syzygyLen>0?[M[1]+1,M[1]+syzygyLen]:0}cosyzygy(M){let injenv=this.injs[M[1]];return this.isInjective(M)?0:[injenv[0],M[0]-1]}isIsom(M,N){return M[0]==N[0]&&M[1]==N[1]}isZero(M){return this.isIsom(M,[0,0])}isProjective(M){return this.isIsom(M,this.projs[M[0]-1])}isInjective(M){return this.isIsom(M,this.injs[M[1]-1])}isNoHom(M,N){return this.isZero(M)||this.isZero(N)||M[0]>N[1]||M[0]<N[0]||M[1]<N[1]}Ker(M,N){let b,K;return this.isNoHom(M,N)?M:[N[1]+1,M[1]]}Image(M,N){let b,I;return this.isNoHom(M,N)?[0,0]:[M[0],N[1]]}Coker(M,N){let b,C=this.isNoHom(M,N)?N:[N[0],M[0]-1];return C[0]>C[1]?[0,0]:C}composedImage(L,M,N){return this.isNoHom(M,N)?[0,0]:this.Image(this.Image(L,M),N)}isFactorThrough(L,M,N){return!this.isNoHom(M,N)&&this.isIsom(this.Image(L,N),this.composedImage(L,M,N))}projRes(M){let sy=this.syzygy(M,this.kupisch),projres=[M[0]];for(;sy;)projres.push(sy[0]),sy=this.syzygy(sy,this.kupisch);return projres}ExtNonVanishingDegree(M,N){const res=this.projRes(M).map(i=>this.projs[i-1]);for(let i=1;i<res.length;i++)if(!this.isNoHom(res[i],N)&&res[i-1][0]<=N[0]&&(!(i<res.length-1)||this.isZero(this.composedImage(res[i+1],res[i],N)))&&!this.isFactorThrough(res[i],res[i-1],N))return i;return-1}isSelfOrthogonal(M){return this.ExtNonVanishingDegree(M,M)<0}LeftOrthoCat(Ms,deg=-1){let d=deg>=0?deg:this.gldim+1;return this.indecs.filter(X=>Ms.reduce((out,M)=>{let x=this.ExtNonVanishingDegree(X,M);return out&&(x>d||-1==x)},!0))}RightOrthoCat(Ms,deg=-1){let d=deg>=0?deg:this.gldim;return this.indecs.filter(X=>Ms.reduce((out,M)=>{let x=this.ExtNonVanishingDegree(M,X);return out&&(x>d||-1==x)},!0))}isTilting(Ms){if(Ms.length<this.rank)return!1;for(let M of Ms)for(let N of Ms)if(this.ExtNonVanishingDegree(M,N)>0)return!1;return!0}tiltingModIrredLeftMutation(T,atX){let idx=Array.isArray(atX)?atX.findIndex(y=>y[0]==atX[0]&&y[1]==atX[1]):atX,TquotX=this.orderDirectSummandsByTopThenLL(T.filter((_,i)=>i!=idx));console.log("tiltingModIrredLeftMutation: TquotX = ",TquotX);let flag=!1,images,nonZeroMapIdx=TquotX.map(M=>this.Image(T[idx],M)).map((Imf,i)=>this.isZero(Imf)?-1:i).filter(j=>-1!=j),approxAt=[];for(let i=0;i<nonZeroMapIdx;i++){let notApprox=!1;for(let j=0;j<i;j++)notApprox=notApprox||this.isFactorThrough(T[idx],TquotX[nonZeroMapIdx[j]],TquotX[nonZeroMapIdx[i]]);notApprox||approxAt.push(i)}if(0==approxAt.length)return T;if(1==approxAt.length)return this.isSub(T[idx],TquotX[approx[0]])?TquotX.concat([this.Coker(T[idx],TquotX[approxAt[0]])]):T;let U=TquotX[approxAt[0]],V=TquotX[approxAt[1]];return TquotX.concat([U[1]<V[1]?[V[0],U[1]]:[U[0],V[1]]])}orderDirectSummandsByTopThenLL(M){return M.toSorted((a,b)=>b[0]-a[0]||a[1]-a[0]-b[1]+b[0])}pdim(M){let d=0,X=M;for(;!this.isProjective(X);)X=this.syzygy(X),d++;return d}idim(M){let d=0,X=M;for(;!this.isInjective(X);)X=this.cosyzygy(X),d++;return d}computeForModule(M){let res={top:M[0],soc:M[1],len:M[1]-M[0]+1};return res.proj=this.isProjective(M),res.inj=this.isInjective(M),res.projres=this.projRes(M),res.pdim=res.projres.length-1,res.syzygy=this.syzygy(M),res}Trace(Ms,N){let hasHom=Ms.filter(M=>!this.isNoHom(M,N)).map(M=>M[0]);return 0==hasHom.length?[0,0]:[Math.min(...hasHom),N[1]]}Rej(M,Ns){let hasHom=Ns.filter(N=>!this.isNoHom(M,N)).map(N=>N[1]);return 0==hasHom.length?M:[Math.max(...hasHom)+1,M[1]]}inductiveConstructModsFromPermutation(perm,base,op){if(perm.length!=this.rank)return[[0,0]];let rev=[...perm].reverse(),mods=Array(perm.length).fill([0,0]),largers=[],i=1;for(mods[rev[0]-1]=base[rev[0]-1];i<rev.length;)largers.push(base[rev[i-1]-1]),mods[rev[i]-1]=op(largers,base[rev[i]-1]),i++;return mods}standardMods(perm){return this.inductiveConstructModsFromPermutation(perm,this.projs,(largers,M)=>this.Coker(this.Trace(largers,M),M))}costandardMods(perm){return this.inductiveConstructModsFromPermutation(perm,this.injs,(largers,M)=>this.Rej(M,largers))}charTilting(std,costd){return std.map((M,i)=>[costd[i][0],std[i][1]])}minAdaptedOrder(std,costd){let dec=std.map((s,i)=>this.projs.reduce((prev,pj,j)=>i==j||this.isNoHom(pj,s)?prev:[...prev,j],[])),inc,TC=TransitiveClosure(BinRelToAdjMx(costd.map((c,i)=>this.projs.reduce((prev,pj,j)=>i==j||this.isNoHom(pj,c)?prev:[...prev,j],dec[i])),!0));return[CoveringRelation(TC),TC]}minAdaptedOrderByPermutation(perm){return this.minAdaptedOrder(this.standardMods(perm),this.costandardMods(perm))}isSub(L,M){return L[1]==M[1]&&L[0]<=M[0]}isQuot(M,N){return M[0]==N[0]&&M[1]>=N[1]}isIndecDirectSummand(M,arrN){return this.isZero(M)?arrN:arrN.reduce((prev,N)=>prev||this.isIsom(M,N),!1)}isDirectSummand(arrM,arrN){let b=!0;for(let M of arrM)if(b=b&&this.isIndecDirectSummand(M,arrN),!b)return!1;return b}partitionQHS(){if(0==this.qhsPoset.length&&this.findAllMAOs(),!this.isGentle)return this.qhsPosetPartitioned=[this.qhsPoset],this.qhsPosetPartitioned;let parts,lastNoRel=this.kupisch.findLastIndex(x=>x>2),hasRelAtEnd=this.rank>2&&2==this.kupisch[this.rank-3];if(lastNoRel<this.rank-1&&!hasRelAtEnd){let lastRel=this.kupisch.slice(0,-2).findLastIndex(x=>2==x),n=this.rank-1-lastRel;this.log.add(`Catalan-type partition: relationless tail of length ${n}`),parts=this.projs.slice(-n).reverse().map((P,i)=>{let Q=this.Coker([this.rank,this.rank],P),re=this.qhsPoset.qhs.flatMap(({charTilt:charTilt},j)=>this.isDirectSummand([P,Q],charTilt)?[j]:[]);return this.log.add(`(Group ${i}) reduction at [${P}]+[${Q}] : ${re.length} modules`),re})}else{let n=this.rank-1-lastNoRel;parts=Array.from({length:n},()=>[]);for(let j=0;j<this.qhsPoset.qhs.length;j++){let tilt=this.qhsPoset.qhs[j].charTilt,done=!1;for(let i=0;i<n-1;i++){let S=[this.rank-i,this.rank-i];if(this.isIndecDirectSummand(S,tilt)){parts[i].push(j),done=!0;break}}done||parts[n-1].push(j)}parts.slice(0,-1).map((p,i)=>{this.log.add(`(Group ${i}) reduction at S(${this.rank-i}): ${p.length} modules`)}),this.log.add(`(Group ${n}) all others: ${parts[n-1].length} modules`)}return this.qhsPosetPartitioned=parts,parts}twistQHS(i,j,covers,std,costd){let struc={coverRel:[...covers],std:structuredClone(std),costd:structuredClone(costd)},res={compare:0,struc:struc,twist:[0,1]};if(-1==covers[i].indexOf(j))return res;if(this.isNoHom(costd[j],costd[i])){if(!this.isSub(std[i],std[j]))return res;struc.std[j]=[j+1,i],struc.costd[i]=[costd[j][0],i+1],res.compare=-1,res.twist=[i,j]}else{if(!this.isNoHom(std[i],std[j])||!this.isQuot(costd[j],costd[i]))return res;struc.std[i]=[i+1,std[j][1]],struc.costd[j]=[i+2,j+1],res.compare=1,res.twist=[i,j]}return[struc.coverRel,struc.relationMx]=this.minAdaptedOrder(struc.std,struc.costd),struc.charTilt=this.charTilting(struc.std,struc.costd),res}neighbourMAOs(std,costd,mao=null){let poset=null==mao?this.minAdaptedOrder(std,costd)[0]:mao,foundList=[];for(let i=0;i<std.length;i++)for(let j=0;j<poset[i].length;j++){let twist=this.twistQHS(i,poset[i][j],poset,std,costd);0!=twist.compare&&foundList.push(twist)}return foundList}findAllMAOs(startingOrder=null){let perm=null==startingOrder?Array.from(Array(this.rank).keys(),x=>x+1):startingOrder;this.log.add(null==startingOrder?"ðŸ’­ computing all qhs (start with canonical initial)":`ðŸ’­ computing all qhs (start with permutation [${startingOrder}])`);let std=this.standardMods(perm),costd=this.costandardMods(perm),[poset,relMx]=this.minAdaptedOrder(std,costd),foundList=[{coverRel:poset,relationMx:relMx,std:std,costd:costd,charTilt:this.charTilting(std,costd)}],qhsPoset=[],i=0,currLen=foundList.length;for(;i<currLen;){let curr=foundList[i],nbhd=this.neighbourMAOs(curr.std,curr.costd),k=0;for(let j=0;j<nbhd.length;j++){let pos=foundList.findIndex(x=>matchingCoverRel(x.coverRel,nbhd[j].struc.coverRel));-1==pos&&(foundList.push(nbhd[j].struc),pos=currLen+k,k++),qhsPoset.push(nbhd[j].compare>0?[i,pos]:[pos,i])}currLen=foundList.length,i++}return this.qhsPoset={qhs:foundList,coverRel:CoveringRelation(TransitiveClosure(TuplesToAdjMx(qhsPoset)))},this.log.add(`âœ” Found all qhs, total: ${foundList.length}`),this.qhsPoset}}function sameAsSet(arr1,arr2){let sorted1=arr1.sort(),sorted2=arr2.sort();return sorted1.reduce((prev,x,i)=>prev&&x==sorted2[i],!0)}function matchingCoverRel(cover1,cover2){return cover1.reduce((prev,x,i)=>prev&&sameAsSet(x,cover2[i]),!0)}function transpose(mx){return mx[0].map((col,i)=>mx.map(row=>row[i]))}function BinRelToAdjMx(rel,transposeMx=!1){let adjMx=rel.map(x=>{let row=Array(rel.length).fill(0);for(let j=0;j<x.length;j++)row[x[j]]=1;return row});return transposeMx?transpose(adjMx):adjMx}function TuplesToAdjMx(arr){let n=Math.max(...arr.flat())+1,adjMx=new Array(n),row=Array(n).fill(0);for(let i=0;i<n;i++)adjMx[i]=row.slice(0);for(let k=0;k<arr.length;k++)adjMx[arr[k][0]][arr[k][1]]=1;return adjMx}function TransitiveClosure(adjMx){for(let k=0;k<adjMx.length;k++)for(let i=0;i<adjMx.length;i++)for(let j=0;j<adjMx.length;j++)adjMx[i][j]=adjMx[i][j]||adjMx[i][k]&&adjMx[k][j];return adjMx}function CoveringRelation(rel){let res=[],baseSet=Array.from(Array(rel.length).keys());for(let i=0;i<rel.length;i++){let coveredBy=[],fromi=baseSet.filter(j=>0!=rel[i][j]);for(let j=0;j<fromi.length;j++){let btwn;0==baseSet.filter(k=>k!=i&&rel[k][fromi[j]]&&rel[i][k]).length&&coveredBy.push(fromi[j])}res.push(coveredBy)}return res}function isMinimalInPoset(i,coverRel){return-1==coverRel.findIndex(coveredBy=>coveredBy.indexOf(i)>-1)}function ArraySplit(arr,separator){let res=[],curr=[];for(let x of arr)x===separator?(res.push(curr),curr=[]):curr.push(x);return curr.length>0&&res.push(curr),res}
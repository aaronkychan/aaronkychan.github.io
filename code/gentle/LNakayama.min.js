class LNakayama{kupisch=[2,1];rank=2;isGentle=!0;log;relations=[];projs=[];injs=[];qhsPoset=[];constructor(kupisch,logger=null){if(this.log=null==logger?new Logger:logger,!this.isLNakayama(kupisch))return this.log;this.kupisch=kupisch,this.rank=kupisch.length,this.relations=this.computeRelations(),this.isGentle=this.relations.reduce((prev,curr)=>prev&&curr[1]-curr[0]==2,!0),this.log.add(`Loaded ${this.isGentle?"":"non-"}gentle LNakayama of rank ${this.rank}.`),this.projs=kupisch.map((l,i)=>[i+1,i+l]),this.injs=Array.from(Array(this.rank).keys()).map(i=>{let j=i;for(;j>=0;){let top=this.relations.filter(r=>r[1]==j);if(top.length>0)return[top[0][0]+2,i+1];j--}return[1,i+1]})}isValidKupisch(kup){let test=!0,i=0;for(;test&&i<kup.length-1;)test=kup[i+1]>=kup[i]-1&&kup[i]-1>=1,i++;return test=test?kup[1]>=kup[kup.length-1]-1:test,test}isLNakayama(kup){if(this.isValidKupisch(kup)){if(1==kup[kup.length-1])return!0;this.log.add("Not LNakayama")}else this.log.add("Not a valid Kupisch series");return!1}isGentle(){return this.isGentle=(this.relations?this.relations:this.computeRelations()).reduce((prev,curr)=>prev&&curr[1]-curr[0]==2,!0),this.isGentle}computeRelations(){let rels=[],i=0;for(;this.kupisch[i]<this.rank-i;)this.kupisch[i]-1!=this.kupisch[i+1]?(rels.push([i,i+this.kupisch[i]]),i=i+this.kupisch[i]-1):i++;return this.relations=rels,rels}isModule(M){return M[1]-M[0]<=this.kupisch[M[0]-1]}syzygy(M){let syzygyLen=this.kupisch[M[0]-1]-(M[1]+1-M[0]);return syzygyLen>0?[M[1]+1,M[1]+syzygyLen]:0}cosyzygy(M){let injenv=this.injs[M[1]];return this.isInjective(M)?0:[injenv[0],M[0]-1]}isIsom(M,N){return M[0]==N[0]&&M[1]==N[1]}isZero(M){return this.isIsom(M,[0,0])}isProjective(M){return this.isIsom(M,this.projs[M[0]])}isInjective(M){return this.isIsom(M,this.injs[M[1]])}pdim(M){let d=0,X=M;for(;!this.isProjective(X);)X=syzygy(X),d++;return d}idim(M){let d=0,X=M;for(;!this.isInjective(X);)X=syzygy(X),d++;return d}isNoHom(M,N){return this.isZero(M)||this.isZero(N)||M[0]>N[1]||M[0]<N[0]||M[1]<N[1]}Ker(M,N){let b,K;return this.isNoHom(M,N)?M:[N[1]+1,M[1]]}Image(M,N){let b,I;return this.isNoHom(M,N)?[0,0]:[M[0],N[1]]}Coker(M,N){let b,C;return this.isNoHom(M,N)?N:[N[0],M[0]-1]}Trace(Ms,N){let hasHom=Ms.filter(M=>!this.isNoHom(M,N)).map(M=>M[0]);return 0==hasHom.length?[0,0]:[Math.min(...hasHom),N[1]]}Rej(M,Ns){let hasHom=Ns.filter(N=>!this.isNoHom(M,N)).map(N=>N[1]);return 0==hasHom.length?M:[Math.max(...hasHom)+1,M[1]]}inductiveConstructModsFromPermutation(perm,base,op){if(perm.length!=this.rank)return[[0,0]];let rev=[...perm].reverse(),mods=Array(perm.length).fill([0,0]),largers=[],i=1;for(mods[rev[0]-1]=base[rev[0]-1];i<rev.length;)largers.push(base[rev[i-1]-1]),mods[rev[i]-1]=op(largers,base[rev[i]-1]),i++;return mods}standardMods(perm){return this.inductiveConstructModsFromPermutation(perm,this.projs,(largers,M)=>this.Coker(this.Trace(largers,M),M))}costandardMods(perm){return this.inductiveConstructModsFromPermutation(perm,this.injs,(largers,M)=>this.Rej(M,largers))}charTilting(std,costd){return std.map((M,i)=>[costd[i][0],std[i][1]])}projRes(M){let sy=this.syzygy(M,this.kupisch),projres=[M[0]];for(;sy;)projres.push(sy[0]),sy=this.syzygy(sy,this.kupisch);return projres}minAdaptedOrder(std,costd){let dec=std.map((s,i)=>this.projs.reduce((prev,pj,j)=>i==j||this.isNoHom(pj,s)?prev:[...prev,j],[])),inc;return CoveringRelation(TransitiveClosure(BinRelToAdjMx(costd.map((c,i)=>this.projs.reduce((prev,pj,j)=>i==j||this.isNoHom(pj,c)?prev:[...prev,j],dec[i])),!0)))}minAdaptedOrderByPermutation(perm){return this.minAdaptedOrder(this.standardMods(perm),this.costandardMods(perm))}isSub(M,N){return M[1]==N[1]&&M[0]<=N[0]}isQuot(M,N){return M[0]==N[0]&&M[1]>=N[1]}isIndecDirectSummand(M,arrN){return arrN.reduce((prev,N)=>prev||this.isIsom(M,N),!1)}isDirectSummand(arrM,arrN){let b=!0;for(let M of arrM)if(b=b&&this.isIndecDirectSummand(M,arrN),!b)return!1;return b}twistQHS(i,j,covers,std,costd){let struc={coverRel:[...covers],std:structuredClone(std),costd:structuredClone(costd)},res={compare:0,struc:struc,twist:[0,1]};if(-1==covers[i].indexOf(j))return res;if(this.isNoHom(costd[j],costd[i])){if(!this.isSub(std[i],std[j]))return res;struc.std[j]=[j+1,i],struc.costd[i]=[costd[j][0],i+1],res.compare=-1,res.twist=[i,j]}else{if(!this.isNoHom(std[i],std[j])||!this.isQuot(costd[j],costd[i]))return res;struc.std[i]=[i+1,std[j][1]],struc.costd[j]=[i+2,j+1],res.compare=1,res.twist=[i,j]}return struc.coverRel=this.minAdaptedOrder(struc.std,struc.costd),struc.charTilt=this.charTilting(struc.std,struc.costd),res}neighbourMAOs(std,costd,mao=null){let poset=null==mao?this.minAdaptedOrder(std,costd):mao,foundList=[];for(let i=0;i<std.length;i++)for(let j=0;j<poset[i].length;j++){let twist=this.twistQHS(i,poset[i][j],poset,std,costd);0!=twist.compare&&foundList.push(twist)}return foundList}findAllMAOs(startingOrder=null){let perm=null==startingOrder?Array.from(Array(this.rank).keys(),x=>x+1):startingOrder;this.log.add(null==startingOrder?"ðŸ’­ computing all qhs (start with canonical initial)":`ðŸ’­ computing all qhs (start with permutation [${startingOrder}])`);let std=this.standardMods(perm),costd=this.costandardMods(perm),poset,foundList=[{coverRel:this.minAdaptedOrder(std,costd),std:std,costd:costd,charTilt:this.charTilting(std,costd)}],qhsPoset=[],i=0,currLen=foundList.length;for(;i<currLen;){let curr=foundList[i],nbhd=this.neighbourMAOs(curr.std,curr.costd),k=0;for(let j=0;j<nbhd.length;j++){let pos=foundList.findIndex(x=>matchingCoverRel(x.coverRel,nbhd[j].struc.coverRel));-1==pos&&(foundList.push(nbhd[j].struc),pos=currLen+k,k++),qhsPoset.push(nbhd[j].compare>0?[i,pos]:[pos,i])}currLen=foundList.length,i++}return this.qhsPoset={qhs:foundList,coverRel:CoveringRelation(TransitiveClosure(TuplesToAdjMx(qhsPoset)))},this.log.add(`âœ” Found all qhs, total: ${foundList.length}`),this.qhsPoset}}function sameAsSet(arr1,arr2){let sorted1=arr1.sort(),sorted2=arr2.sort();return sorted1.reduce((prev,x,i)=>prev&&x==sorted2[i],!0)}function matchingCoverRel(cover1,cover2){return cover1.reduce((prev,x,i)=>prev&&sameAsSet(x,cover2[i]),!0)}function transpose(mx){return mx[0].map((col,i)=>mx.map(row=>row[i]))}function BinRelToAdjMx(rel,transposeMx=!1){let adjMx=rel.map(x=>{let row=Array(rel.length).fill(0);for(let j=0;j<x.length;j++)row[x[j]]=1;return row});return transposeMx?transpose(adjMx):adjMx}function TuplesToAdjMx(arr){let n=Math.max(...arr.flat())+1,adjMx=new Array(n),row=Array(n).fill(0);for(let i=0;i<n;i++)adjMx[i]=row.slice(0);for(let k=0;k<arr.length;k++)adjMx[arr[k][0]][arr[k][1]]=1;return adjMx}function TransitiveClosure(adjMx){for(let k=0;k<adjMx.length;k++)for(let i=0;i<adjMx.length;i++)for(let j=0;j<adjMx.length;j++)adjMx[i][j]=adjMx[i][j]||adjMx[i][k]&&adjMx[k][j];return adjMx}function CoveringRelation(rel){let res=[],baseSet=Array.from(Array(rel.length).keys());for(let i=0;i<rel.length;i++){let coveredBy=[],fromi=baseSet.filter(j=>0!=rel[i][j]);for(let j=0;j<fromi.length;j++){let btwn;0==baseSet.filter(k=>k!=i&&rel[k][fromi[j]]&&rel[i][k]).length&&coveredBy.push(fromi[j])}res.push(coveredBy)}return res}